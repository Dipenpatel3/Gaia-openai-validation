from data.data_read import insert_model_response
from data.data_s3 import RETRIEVAL_EXT, CI_EXT, IMG_EXT, MP3_EXT, ERR_EXT

def ask_gpt(openai_client, system_content: str, question_selected: str, format_type: int, model: str, loaded_file: dict = None, annotated_steps: str = None):
    """
    Sends a prompt to the GPT model using the specified parameters and returns the model's response.

    Args:
        openai_client (OpenAIClient): The client instance used to interact with the OpenAI API.
        system_content (str): The system message that sets the context for the model.
        question_selected (str): The question that requires a response from the model.
        format_type (int): The format type used to determine how the content is structured.
                           - 0: Basic formatting
                           - 1 and 2: Uses transcription data
                           - 3: Uses annotated steps
        model (str): The model to be used for generating the response (e.g., "gpt-4").
        loaded_file (dict, optional): The file details dictionary containing 'path', 'extension', and optionally 'url' 
                                      if a file is provided. Used for handling file-based prompts. Defaults to None.
        annotated_steps (str, optional): The annotated steps to be included when 'format_type' is 3. Defaults to None.

    Returns:
        str: The response generated by the model or an error message if the file extension is not supported.
    """
    if format_type == 0:
        validation_content = openai_client.format_content(format_type, question_selected)
    elif format_type == 3:
        validation_content = openai_client.format_content(format_type, question_selected, None, annotated_steps)
    if loaded_file:
        # print(loaded_file)
        if loaded_file["extension"] in RETRIEVAL_EXT:
            ai_response = openai_client.file_validation_prompt(loaded_file["path"], system_content, validation_content, model)
        elif loaded_file["extension"] in CI_EXT:
            ai_response = openai_client.ci_file_validation_prompt(loaded_file["path"], system_content, validation_content, model)
        elif loaded_file["extension"] in IMG_EXT:
            ai_response = openai_client.validation_prompt(system_content, validation_content, model, loaded_file["url"])
        elif loaded_file["extension"] in ERR_EXT:
            ai_response = "The LLM model currently does not support these file extensions."
        else:
            transcription = openai_client.stt_validation_prompt(loaded_file["path"])
            if format_type == 1:
                validation_content = openai_client.format_content(format_type, question_selected, transcription)
            elif format_type == 2:
                validation_content = openai_client.format_content(format_type, question_selected, transcription, annotated_steps)
            ai_response = openai_client.validation_prompt(system_content, validation_content, model)

    else:
        # print(validation_content)
        ai_response = openai_client.validation_prompt(system_content, validation_content, model)
    
    return ai_response

def answer_validation_check(final_answer: str,validation_answer: str) -> bool:
    """
    Checks whether the final answer is present in the validation answer. The check is case-insensitive 
    and handles both numeric and non-numeric answers.

    Args:
        final_answer (str): The answer provided that needs to be validated.
        validation_answer (str): The correct answer against which validation is performed.

    Returns:
        bool: Returns True if the final answer is not present in the validation answer, 
              otherwise returns False.
    """
    final_answer = final_answer.strip().lower()
    validation_answer = validation_answer.strip().lower().replace('`', '')

        # Check if final_answer consists only of numbers
    if final_answer.isdigit():
        # Convert validation_answer to a list of elements split by whitespace
        validation_list = validation_answer.split()
        
        # Check if final_answer exists in the validation_list
        return final_answer not in validation_list
    else:
        # If final_answer is not only numbers, perform the original check
        return final_answer not in validation_answer